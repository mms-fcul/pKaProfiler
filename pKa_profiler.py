#! /usr/bin/python
import argparse
import math
import matplotlib.pyplot as plt
import numpy as np
import sys
from argparse import RawTextHelpFormatter
from scipy.optimize import curve_fit

"""
input files: 
 - insertion file: {insertion_dir(str)}/{pH_value(float)}_r{replicate(str)}_insertion.xvg
time insertion_value

 - concatenated protonation file: {prot_dir(str)}/all_{pH_value(float)}_{replicate(str)}.dat
time protonation 

output file:
#header
time insertion_value protonation_state pH_value replicate


the script fails if protonation and insertion time frames do not overlap.
the user should align the time stamps of the input files
Ex:
Insertion Protonation
1         2
3         4
5         6
7         8
"""

### PROG INPUT AND DESCRIPTION ###
parser = argparse.ArgumentParser(description='The program takes insertion and protonation files of a membrane inserted protein and generates a pKa profile. This profile is generated by a 4 step procedure:\n -Assignment: where each protonation state is assigned to the respective insertion value of the residue for each pH and each replicate;\n -Slicing: after the assignment, each pair (insertion and protonation state) is separated according to a slice (or bin) delimitated by an insertion range. The process is dependent of user input regarding the range of insertion values to evaluate, bin size and the step between bins;\n -Fit: for each slice it will be calculated a pKa value by fitting the data to either an Henderson-Hasselbach or Hill equation. Each slice needs to pass 3 criterions: each protonation state for each pH must have at least 50 points, the monotonicity must not vary above 0.05 and the average protonation must be within a 0.001 tolerance;\n -Error: the standard error of the mean is calculated by performing the previous steps, individually, on the data of 5 resampled combinations of the replicates (eg.:1234, 1235,1245,1345,2345). After having 5 pKa values for each slice, it calculates the standard deviation for each slice and obtain the error.\n',formatter_class=RawTextHelpFormatter)
\

parser.add_argument('f', help = 'Parameter filename\n'
                    'Requires the following parameters: insertion directory path '
                    '("insertion_dir"), protonation dir path ("prot_dir"), list of '
                    'pH_values (pH_values = []), list of replicates (replicates = []), '
                    'minimum and maximum value of slicing\n ("min_value = ","max_value") '
                    'size of step and bin size ("step=","bin_size"), monotonicity variation '
                    '("mono_variation="), "tolerance=" and cutoff of number of points per '
                    'protonation state to consider a slice ("cutoff=")\n',
                    metavar='input')



# Default Variables #
insertion_dir = ''
prot_dir      = ''
criteria_dir  = ''

# pH VALUES AND REPLICATES
pH_values   = []
replicates  = []

# INSERTION RANGE
min_value = -10
max_value = 10
step      = 0.5
bin_size  = 0.5

# FIT
fit = "Hill"
mono_variation = 0.05
tolerance      = 0.001
cutoff         = 10

# EXCLUSION CRITERIA
crits_names = []
crits = []

# OUTPUT
output_file = "testing"


# Parse Input Variables #
args = parser.parse_args()
input_file = args.f.split('.')[0]
exec("from {} import *".format(input_file))


ncrits       = len(crits)


### USER DEFINED VARIABLES ###

log_file  = 'LOG_fit'
n         = 1.0
pKa_guess = 0

### FUNCTIONS ###
def defVariables(pH_values, replicates):
    """
    trj is dict with the following structure, 
        where time, insertion and protonation lists 
        have corresponding indexes:
        trj = {
               pH_value1: {
                           replicate1: {
                                        'time': [],
                                        'insertion': [],
                                        'protonation': [],
                                        'slices': []
                                       },
                           replicate2: {
                                        'time': [],
                                        'insertion': [],
                                        'protonation': [],
                                        'slices': []
                                       }
                          },
               pH_value2: {
                           replicate1: {
                                        'time': [],
                                        'insertion': [],
                                        'protonation': [],
                                        'slices': []
                                       },
                           replicate2: {
                                        'time': [],
                                        'insertion': [],
                                        'protonation': [],
                                        'slices': []
                                       }
              ...
              }
    """
    trj = {}
    for j in pH_values:
        trj[j] = {}
        for k in replicates:
            trj[j][k] = {'time':[], 'insertion':[], 'protonation':[], 'slices':[]}
            
    return trj


def defSlices(min_value, max_value, step, bin_size):
    """
    slice_range = {
                   interval1:  {
                               'points': [(pH, rep, time), ...],
                               'fit_all': 0,
                               'fit_all_but1': 0,
                               'fit_all_but2': 0,
                               'fit_all_but3': 0
                               ...
                               }
                  ...
                  }
    """
    slice_range = {}
    max_value += 1

    for i in np.arange(min_value, max_value, step):
        content = {'points': [], 'fit_all': None}
        for rep in replicates:
            content['fit_all_but{0}'.format(rep)] = None
        slice_range[(i, i + bin_size)] = content

    return slice_range
  
def iterFiles(trj, root_dir, file_type):
    """Iterate through all file paths 
    of given pH values, replicates and file type"""

    if file_type not in ('insertion', 'protonation'):
        raise Exception('In iterFiles function, file_type variable '
                        'needs to either "insertion" or "protonation"')    
    for pH in trj.keys():
        for replicate in trj[pH]:
            if file_type == 'insertion':
                file_dir = '{0}/analysis-r{1}-{2}_insertion.xvg'.format(root_dir,
                                                                        replicate, pH)
            elif file_type == 'protonation':
                file_dir = '{0}/all_pH{1}_r{2}.dat'.format(root_dir, pH,
                                                           replicate)

            yield file_dir, pH, replicate

def CriteriaLine(crite_dir):
    with open(crite_dir) as c:           
        for line in c:
            yield line

def readInsertionFiles(trj, insertion_dir, criteria_dir):
    """Store time and insertion from input insertion files"""
    log = ''

    for file_dir, pH, replicate in iterFiles(trj, insertion_dir, 'insertion'):
        with open(file_dir) as f: 
            all_lines  = f.readlines()

            # skip first line if output from membit
            if 'time' in all_lines[0] or all_lines[0][0] in ('#', '@'):
                all_lines = all_lines[1:]

        if ncrits > 0:
            crite_dir = '{0}/criteria_pH{1}_rep{2}'.format(criteria_dir, pH,
                                                           replicate)

            cline_it = CriteriaLine(crite_dir)

        for fline in all_lines:
            trigger_continue = False
            # skip empty lines
            if len(fline) <= 1:
                continue

            l_cols = fline.split()
            time_i    = float(l_cols[0])
            insertion = float(l_cols[1])

            if min_value < insertion and insertion < max_value:
                trigger_continue = True
                    
            if ncrits > 0:
                try:
                    cline = next(cline_it)
                except:
                    raise IOError('Error while reading {0} criteria file.\n'
                                  'Please check if the last time matches the '
                                  'last time in {1} insertion file.'.format(crite_dir, file_dir))

            	c_cols = cline.split()
            	time_c = float(c_cols[0])

            	if time_i != time_c:
            	    raise IOError('Inconsistency between insertion file {}'
            	                  ' and criteria file {} time columns.'.format(file_dir, crit_dir))

                if ncrits != len(c_cols) - 1:
            	    raise IOError('Inconsistent number of criteria ranges '
            	                  'and columns in the criteria input file')

                
            	crit_values = c_cols[1:]
                for crit_i in range(ncrits):

            	    crit_value = float(crit_values[crit_i])
            	    crit_min = crits[crit_i]['crit_min']
            	    crit_max = crits[crit_i]['crit_max']

            	    if crit_value >= crit_min and crit_value <= crit_max:
                        trigger_continue = True
                    else:
                        trigger_continue = False

            if trigger_continue:
                slices = assignToSlices(pH, replicate, time_i, insertion)

                trj[pH][replicate]['time'].append(time_i)
                trj[pH][replicate]['insertion'].append(insertion)
                trj[pH][replicate]['slices'].append(slices)

            else:
                log += '{0} {1} {2}\n'.format(time_i, pH, replicate)

    with open("Crit_Log.txt", "w") as f_new:
        log = 'time pH rep\n' + log
        f_new.write(log)       

    return trj


def assignToSlices(pH, replicate, time, insertion):
    slice_list = []

    for slice_b, slice_e in slice_range.keys():
        if slice_b < insertion and insertion <= slice_e:

            slice_range[(slice_b, slice_e)]['points'].append((pH, replicate, time))
            slice_list.append((slice_b, slice_e))

    return slice_list


def ProtonationLine(file_dir):
    with open(file_dir) as f:
        all_lines = f.readlines()

        first_line_cols = all_lines[0].split()
        last_prot_time = float(first_line_cols[0])
        last_prot = float(first_line_cols[1])
        last_index = 0

        for line in all_lines:
            if len(line) <= 1:
                continue
            cols_prot = line.split()
            time = float(cols_prot[0])
            prot = float(cols_prot[1])                
            if prot != 0 and prot != 1:
                raise Exception("Invalid protonation value. "
                                "Check your protonation file!")
            yield time, prot, last_prot_time, last_prot

            last_prot_time = time
            last_prot = prot


def assignProtonation(pH, replicate, insertion_time, prot,
                      time, i, nempty_times):
    while i <= nempty_times:
        insertion_time = trj[pH][replicate]['time'][i]
        if insertion_time < time + prot_lifetime:
            if time <= insertion_time:
                trj[pH][replicate]['protonation'].append(prot)

            else:
                del trj[pH][replicate]['time'][i]
                del trj[pH][replicate]['insertion'][i]
                i -= 1
                nempty_times -= 1

            i += 1
        else:
            return i, insertion_time, nempty_times

    return i, insertion_time, nempty_times


def readProtonationFiles(trj, prot_dir):
    """Store time and protonation from input protonation files"""
    for file_dir, pH, replicate in iterFiles(trj, prot_dir, 'protonation'):
        prot_lines = ProtonationLine(file_dir)

        nempty_times = len(trj[pH][replicate]['time']) - 1
        insertion_time = trj[pH][replicate]['time'][0]
        i = 0

        for time, prot, last_prot_time, last_prot in prot_lines:
            i, insertion_time, nempty_times = assignProtonation(pH, replicate,
                                                                insertion_time,
                                                                prot, time, i,
                                                                nempty_times)

        del trj[pH][replicate]['time'][i:]
        del trj[pH][replicate]['insertion'][i:]

        # DEBUG #
        #print trj[pH][replicate]['time'][:11]
        #print trj[pH][replicate]['insertion'][:11]
        #print trj[pH][replicate]['protonation'][:11]
        #
        #print '\n'
        #
        #print trj[pH][replicate]['time'][-11:]
        #print trj[pH][replicate]['insertion'][-11:]
        #print trj[pH][replicate]['protonation'][-11:]
        #
        #print len(trj[pH][replicate]['time']), len(trj[pH][replicate]['insertion']), len(trj[pH][replicate]['protonation'])

    return trj


def fitfunction(pH, n, pKa_guess):
    pKa = pKa_guess
    if pKa == 0:
        pass
    else:
        if fit == "Hill":
            return 1.0/(1.0+10.0**(n*(pH-pKa)))
        if fit == "HH":
            return 1.0/(1.0+10.0**(pH-pKa))
        else:
            raise Exception("You must choose the fit equation: hill or HH.") 

def fitSlices(slice_range, trj):
    print '## begin fit ##'
    n         = 1.0
    pKa_guess = 0
    out_err   = {}
    fit_err   = {}
    logfit    = {}
    for tuples in sorted(slice_range.keys()):
        all_reps  = {'xdata':[],'ydata':[]}
        if len(slice_range[tuples]['points']) < 1:
            continue

        all_buts  = {}
        values_jk = []
        pH_cutoff = 0
        for rep in replicates:
            all_buts["all_but"+str(rep)] = {'x_data':[],'y_data':[]}

        for i in slice_range[tuples]['points']:
            fpH   = i[0]
            frep  = i[1]
            ftime = i[2]
            if ftime in trj[fpH][frep]['time']:

                findex = trj[fpH][frep]['time'].index(ftime)
                fprot  = trj[fpH][frep]['protonation'][findex]
                pHf    = float(fpH)

                for rep in replicates:
                    if rep != frep:
                        all_buts["all_but"+str(rep)]['x_data'].append(pHf)
                        all_buts["all_but"+str(rep)]['y_data'].append(fprot)                    
                all_reps['xdata'].append(pHf)
                all_reps['ydata'].append(fprot)                

        if len(all_reps['ydata']) > 0 and len(all_reps['ydata']) == len(all_reps['xdata']):

            x_values = all_reps['xdata']
            y_values = all_reps['ydata']

            point_all = 0
            mono_all  = 0

            xdata, ydata, point_all, mono_all, pKa_guess = criteria(x_values,y_values)

            x=np.array(xdata)
            y=np.array(ydata)

            init_vals = [n, pKa_guess]

            if point_all > 2 and mono_all > 2:
                
                popt, pcov = curve_fit(fitfunction, x, y, p0=init_vals, maxfev=5000)
                n_fit      = popt[0]
                pKa_fit    = popt[1]
                slice_range[tuples]['fit_all'] = pKa_fit

                
                print '->', pKa_fit
                for comb in all_buts:
                    x_but = all_buts[comb]['x_data']
                    y_but = all_buts[comb]['y_data']
                    pH_prots_buts = {}
                    if len(y_but) > 1 and len(y_but) == len(x_but):                       
                
                        point_but = 0
                        mono_but  = 0
                        
                        xdata, ydata, point_but, mono_but, pKa_guess = criteria(x_but,y_but)
                
                        x=np.array(xdata)
                        y=np.array(ydata)
                
                        init_vals = [n, pKa_guess]
                
                        if point_but > 1  and mono_but > 1: 
                
                            popt, pcov = curve_fit(fitfunction, x, y, p0=init_vals)
                            allbut_n_fit      = popt[0]
                            allbut_pKa_fit    = popt[1]
                            slice_range[tuples]['fit_' + str(comb)] = allbut_pKa_fit
                            values_jk.append(allbut_pKa_fit)
                            logfit.update({comb:allbut_pKa_fit})
                
                        else:
                            continue

                if len(values_jk) > 1:
                    pKa_err, stde_err = jackknife(values_jk)
                else:
                    stde_err = "NaN"
                    log_fit  = "NaN"
                mean_slab = ((tuples[0] + tuples[1])/2)
                out_err.update({mean_slab:[pKa_fit, stde_err]})
                fit_err.update({mean_slab:logfit})

    return slice_range, out_err, fit_err


#### Tolerance and Monotonicity Criteria ####
def criteria(x, y):
    guess_data = {}
    pH_prots   = {}
    pKa_guess  = 0
    pH_guess   = 0
    prot       = 0
    xdata      = []
    ydata      = []
    
    for pH in pH_values:
        pH_prots[float(pH)] = []

        
    for i in range(len(x)):
        pH = float(x[i])
        if pH in pH_prots.keys():
            pH_prots[pH].append(y[i])
                              
    previous   = 1
    point_crit = 0
    mono_crit  = 0
    for pH in pH_values:
        pH = float(pH)
        zero = 0
        one  = 0
        for i in range(len(pH_prots[pH])):
            if float(pH_prots[pH][i]) == 0:
                zero += 1
            else:
                one  += 1


        if zero > cutoff and one > cutoff:
            crit_value_zero = zero / float(zero + one)
            crit_value_one  = one  / float(one + zero)

            if crit_value_zero > tolerance:
                point_crit += 1
                
            if crit_value_one - mono_variation < previous:
                mono_crit  += 1
                previous   = crit_value_one

            shift = float((one/(one+zero))-0.5)
            prev  = 1
            avg_prot = one / float(zero+one)
            guess_data[pH] = [avg_prot,shift]

            for j in range(len(pH_prots[pH])):
                xdata.append(pH)
                ydata.append(avg_prot)


            if pH in guess_data.keys() and (math.sqrt(float(guess_data[pH][1])**2)) < prev:
                    prev     = math.sqrt(float(guess_data[pH][1])**2)
                    pH_guess = pH
                    prot     = guess_data[pH][0]

            else:
                continue

        if prot != 0:
            pKa_guess = float( pH_guess - (math.log((1/prot)-1)/math.log(10)))
        else:
            pKa_guess = 6.0
    return  xdata, ydata, point_crit, mono_crit, pKa_guess


def writeOutput(trj, slice_range, out_err, fit_err, output_file, log_file):
    """Write output file in the desired format:
    #header
    time insertion_value protonation_state pH_value replicate slices
    """

    with open(log_file, 'w') as h:
        h.write('slice pKa_fits_combs\n')
        for slices in sorted(fit_err):
            pKa_fit = fit_err[slices]
            h.write('{0} {1} \n'.format(slices, pKa_fit))

    with open(output_file, 'w') as h:
        h.write('slice pKa std_error\n')
        for slices in sorted(out_err):
            pKa_fit = out_err[slices][0]
            std_err = out_err[slices][1]
            h.write('{0} {1} {2}\n'.format(slices, pKa_fit, std_err))

def jackknife(values):
    """adapted from Diogo V. Vicosa jackknife script"""
    # Calculate average
    s       = sum(values)
    n       = len(values)
    avx     = s/n

    # Calculate std dev from a Jackknife resampling
    std_dev = 0
    for i in range(len(values)):
      partial_avx = 0
      for j in range(len(values)):
        if j != i:
          partial_avx = partial_avx + values[j]
      std_dev = std_dev + (avx - partial_avx / (n - 1)) ** 2

    std_dev = 2 * math.sqrt(std_dev * (n - 1) / n)

    return avx, std_dev

if __name__ == '__main__':
    # Define Variables
    trj = defVariables(pH_values, replicates)

    # Define Slices
    slice_range = defSlices(min_value, max_value, step, bin_size)

    # Read Insertion Files
    trj = readInsertionFiles(trj, insertion_dir, criteria_dir)

    # Read Protonation File
    trj = readProtonationFiles(trj, prot_dir)

    # Fit slices and calculate error bars
    slice_range, out_err, fit_err = fitSlices(slice_range, trj)

    # Write output
    writeOutput(trj, slice_range, out_err, fit_err, output_file, log_file)
